
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user making the request is an admin
    function isRequesterAdmin() {
      // Check if the authenticated user exists and has an 'admin' role in their user document
      return request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // Users collection: /users/{userId}
    match /users/{userId} {
      // READ:
      // 1. Authenticated user can read their own profile.
      // 2. Admin can read any user profile.
      allow read: if request.auth != null && (request.auth.uid == userId || isRequesterAdmin());

      // CREATE:
      // 1. Authenticated user can create their own profile document during signup.
      // 2. The 'uid' in the document must match the authenticated user's uid.
      // 3. New users are always assigned the 'user' role (no self-promotion to admin).
      // 4. 'email' must match the authenticated user's email.
      // 5. 'createdAt' must be set by the server.
      // 6. Ensure all required fields are present.
      allow create: if request.auth != null &&
                     request.auth.uid == userId &&
                     request.resource.data.uid == request.auth.uid &&
                     request.resource.data.email == request.auth.token.email &&
                     request.resource.data.role == 'user' &&
                     request.resource.data.createdAt == request.time &&
                     request.resource.data.keys().hasAll(['uid', 'displayName', 'email', 'role', 'createdAt']);

      // UPDATE:
      // 1. Authenticated user can update their own 'displayName'.
      //    - Cannot change 'uid', 'email', 'role', 'createdAt'.
      // 2. Admin can update any user's 'role' and 'displayName'.
      //    - Cannot change 'uid', 'email', 'createdAt'.
      allow update: if request.auth != null && (
                      ( // Case 1: User updating their own profile
                        request.auth.uid == userId &&
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email &&
                        request.resource.data.role == resource.data.role && // User cannot change their own role
                        request.resource.data.createdAt == resource.data.createdAt &&
                        request.resource.data.keys().hasAll(['uid', 'displayName', 'email', 'role', 'createdAt']) &&
                        // Check that only allowed fields are being changed by the user
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName']) ||
                         request.resource.data.diff(resource.data).affectedKeys().size() == 0) // No changes is also ok
                      ) ||
                      ( // Case 2: Admin updating a user's profile
                        isRequesterAdmin() &&
                        request.resource.data.uid == resource.data.uid &&
                        request.resource.data.email == resource.data.email && // Admin cannot change email (tied to auth)
                        request.resource.data.createdAt == resource.data.createdAt && // createdAt is immutable
                        request.resource.data.keys().hasAll(['uid', 'displayName', 'email', 'role', 'createdAt']) &&
                        // Admin can change 'displayName' and 'role'
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['displayName', 'role']) ||
                         request.resource.data.diff(resource.data).affectedKeys().hasAny(['displayName', 'role']) || // if changing one or both
                         request.resource.data.diff(resource.data).affectedKeys().size() == 0) // No changes is also ok
                      )
                    );

      // DELETE:
      // 1. Only admins can delete user profiles.
      allow delete: if request.auth != null && isRequesterAdmin();
    }

    // Notifications collection: /notifications/{notificationId}
    match /notifications/{notificationId} {
      // READ:
      // 1. Authenticated user can read broadcast notifications (recipientId == null).
      // 2. Authenticated user can read private notifications sent to them (recipientId == request.auth.uid).
      // 3. Admin can read all notifications.
      allow read: if request.auth != null &&
                    (resource.data.recipientId == null ||
                     resource.data.recipientId == request.auth.uid ||
                     isRequesterAdmin());

      // CREATE:
      // 1. Only admins can create notifications.
      // 2. 'senderId' must be the admin's UID.
      // 3. 'timestamp' must be set by the server.
      // 4. Ensure only allowed fields are present.
      allow create: if request.auth != null &&
                     isRequesterAdmin() &&
                     request.resource.data.senderId == request.auth.uid &&
                     request.resource.data.timestamp == request.time &&
                     // Ensure all required fields are there and no unexpected fields
                     request.resource.data.keys().hasAll(['title', 'message', 'senderId', 'timestamp']) &&
                     request.resource.data.keys().hasOnly(['title', 'message', 'senderId', 'timestamp', 'recipientId', 'fileUrl', 'fileName', 'fileType']);


      // UPDATE: (Notifications are generally immutable once sent)
      // Let's disallow updates to notifications for simplicity.
      // If updates were needed (e.g., to mark as read by admin, or correct typos),
      // this rule would be more specific and restricted to admins.
      allow update: if false;

      // DELETE:
      // 1. Only admins can delete notifications.
      allow delete: if request.auth != null && isRequesterAdmin();
    }
  }
}
